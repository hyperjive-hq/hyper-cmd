"""MCP initialization command for setting up .mcp.json configuration."""

import json
import os
import shutil
from pathlib import Path
from typing import Any, Optional

from .base import BaseCommand


class MCPConfigGenerator:
    """Generates MCP configuration for Hyper CLI integration."""

    # MCP schema URL for validation
    MCP_SCHEMA_URL = "https://raw.githubusercontent.com/modelcontextprotocol/specification/main/schema/mcp_config.schema.json"

    @classmethod
    def generate_config(cls) -> dict[str, Any]:
        """Generate the standard MCP configuration for Hyper CLI."""
        return {
            "mcpServers": {
                "hyper-cmd": {
                    "command": "uvx",
                    "args": ["--from", ".", "hyper-mcp"],
                    "env": {},
                    "description": "Hyper CMD CLI commands via MCP for AI integration",
                }
            },
            "$schema": cls.MCP_SCHEMA_URL,
            "version": "1.0",
            "description": "MCP configuration for Hyper CMD integration - auto-generated by hyper init-mcp",
        }

    @classmethod
    def read_config(cls, config_file: Path) -> dict[str, Any]:
        """Read existing MCP configuration from file."""
        if not config_file.exists():
            return {}

        try:
            with open(config_file, encoding="utf-8") as f:
                return json.load(f)
        except (json.JSONDecodeError, OSError) as e:
            raise ValueError(f"Failed to read existing config: {e}") from e

    @classmethod
    def merge_config(
        cls, existing_config: dict[str, Any], new_config: dict[str, Any]
    ) -> dict[str, Any]:
        """Merge new configuration with existing one, preserving existing servers."""
        if not existing_config:
            return new_config

        # Start with existing config
        merged = existing_config.copy()

        # Ensure mcpServers exists
        if "mcpServers" not in merged:
            merged["mcpServers"] = {}

        # Add or update hyper-cmd server
        merged["mcpServers"].update(new_config["mcpServers"])

        # Update schema and version if they exist in new config
        if "$schema" in new_config:
            merged["$schema"] = new_config["$schema"]
        if "version" in new_config:
            merged["version"] = new_config["version"]

        return merged

    @classmethod
    def write_config(cls, config_file: Path, config: dict[str, Any]) -> None:
        """Write MCP configuration to file with proper formatting."""
        with open(config_file, "w", encoding="utf-8") as f:
            json.dump(config, f, indent=2, ensure_ascii=False)
            f.write("\n")  # Add trailing newline


class MCPToolDetector:
    """Detects MCP-compatible tools and existing configurations."""

    @classmethod
    def detect_tools(cls) -> list[str]:
        """Detect common MCP-compatible tools in the environment."""
        tools_found = []

        # Check for Claude Code environment variable
        if os.environ.get("CLAUDE_CODE"):
            tools_found.append("Claude Code")

        # Check for common MCP config locations
        existing_configs = cls._find_existing_configs()
        if existing_configs:
            tools_found.append(f"Existing MCP configs: {len(existing_configs)}")

        return tools_found

    @classmethod
    def _find_existing_configs(cls) -> list[Path]:
        """Find existing MCP configuration files."""
        home = Path.home()
        common_configs = [
            home / ".config" / "claude-code" / "mcp.json",
            home / ".claude" / "mcp.json",
            Path.cwd() / "mcp.json",
            Path.cwd() / ".mcp.json",
        ]

        return [p for p in common_configs if p.exists()]


class McpInitCommand(BaseCommand):
    """Initialize MCP configuration for Hyper CLI integration.

    This command creates or updates .mcp.json file with the configuration
    needed to connect the Hyper CLI MCP server to AI tools like Claude Code.
    """

    def __init__(self, container=None):
        """Initialize the command."""
        super().__init__(container)
        self.config_generator = MCPConfigGenerator()
        self.tool_detector = MCPToolDetector()

    @property
    def name(self) -> str:
        return "init-mcp"

    @property
    def description(self) -> str:
        return "Initialize MCP configuration for Hyper CLI integration"

    @property
    def help_text(self) -> str:
        return """
        Usage: hyper init-mcp [--force] [--config-path PATH]

        Initialize MCP (Model Context Protocol) configuration for Hyper CLI integration.

        This command creates or updates a .mcp.json file that configures AI tools
        (like Claude Code) to connect to the Hyper CLI MCP server, enabling AI
        agents to execute Hyper commands.

        Smart merge behavior:
        - Automatically detects existing .mcp.json files
        - Prompts to merge with existing servers or overwrite completely
        - Preserves other MCP servers while adding/updating hyper-cmd

        Options:
            --force          Overwrite existing .mcp.json file without confirmation
            --config-path    Path to save .mcp.json (default: current directory)

        Examples:
            hyper init-mcp                    # Create .mcp.json in current directory
            hyper init-mcp --force            # Overwrite existing config
            hyper init-mcp --config-path ~/   # Save to home directory

        After running this command:
        1. The .mcp.json file will be created with Hyper CLI server configuration
        2. AI tools can connect to the Hyper CLI via MCP protocol
        3. AI agents will have access to all non-interactive Hyper commands
        """

    def execute(self, force: bool = False, config_path: Optional[str] = None) -> int:
        """Execute the init-mcp command.

        Args:
            force: Skip confirmation and overwrite existing files
            config_path: Path where to save .mcp.json file

        Returns:
            Exit code (0 for success, non-zero for failure)
        """
        # Check if uvx is available first
        if not shutil.which("uvx"):
            self.print_error("uvx is required but not found in PATH")
            self.console.print(
                "\n[bold red]Error:[/bold red] uvx is not installed or not available"
            )
            self.console.print("\n[bold]uvx is required for reliable MCP server execution.[/bold]")
            self.console.print("Please install uvx using one of these methods:")
            self.console.print("  • [cyan]pip install uv[/cyan]")
            self.console.print("  • [cyan]pipx install uv[/cyan]")
            self.console.print("  • [cyan]curl -LsSf https://astral.sh/uv/install.sh | sh[/cyan]")
            self.console.print("\nThen run [cyan]hyper init-mcp[/cyan] again.")
            return 1

        try:
            # Determine and validate config file location
            config_file = self._determine_config_file(config_path)
            if config_file is None:
                return 1

            # Check for existing file and determine merge strategy
            merge_strategy = self._determine_merge_strategy(config_file, force)
            if merge_strategy is None:
                return 1

            # Generate configuration based on merge strategy
            new_config = self.config_generator.generate_config()
            if merge_strategy == "merge":
                existing_config = self.config_generator.read_config(config_file)
                config = self.config_generator.merge_config(existing_config, new_config)
                self._show_merge_preview(existing_config, config, config_file)
            else:
                config = new_config
                self._show_config_preview(config, config_file)

            # Get final confirmation if not using force
            if not force and not self._confirm_proceed():
                self.print_info("MCP initialization cancelled.")
                return 1

            # Write configuration file
            self._write_config_file(config_file, config)

            # Show success message and next steps
            self._show_success_message(config_file)

            return 0

        except Exception as e:
            self.print_error(f"Failed to initialize MCP configuration: {e}")
            return 1

    def _determine_config_file(self, config_path: Optional[str]) -> Optional[Path]:
        """Determine and validate the config file location."""
        if config_path:
            config_dir = Path(config_path).resolve()
        else:
            config_dir = Path.cwd()

        # Validate directory
        if not config_dir.exists():
            self.print_error(f"Directory does not exist: {config_dir}")
            return None

        if not config_dir.is_dir():
            self.print_error(f"Path is not a directory: {config_dir}")
            return None

        return config_dir / ".mcp.json"

    def _determine_merge_strategy(self, config_file: Path, force: bool) -> Optional[str]:
        """Determine how to handle existing configuration file.

        Returns:
            "overwrite" - Replace existing file
            "merge" - Merge with existing file
            None - User cancelled
        """
        if not config_file.exists():
            return "overwrite"

        if force:
            return "overwrite"

        # Try to read existing config to see if it has other servers
        try:
            existing_config = self.config_generator.read_config(config_file)
            existing_servers = existing_config.get("mcpServers", {})

            # Check if hyper-cmd already exists
            has_hyper_cmd = "hyper-cmd" in existing_servers
            has_other_servers = len([k for k in existing_servers.keys() if k != "hyper-cmd"]) > 0

            if has_other_servers:
                self.print_info(f"Found existing MCP configuration at {config_file}")
                self.console.print(f"  📋 Existing servers: {', '.join(existing_servers.keys())}")

                if has_hyper_cmd:
                    self.print_warning("hyper-cmd server already exists in configuration")

                return self._prompt_merge_strategy(has_hyper_cmd)
            elif has_hyper_cmd:
                self.print_warning(f"hyper-cmd server already exists at {config_file}")
                return self._confirm_overwrite_strategy()
            else:
                # Empty or minimal config, just overwrite
                self.print_warning(f".mcp.json already exists at {config_file}")
                return self._confirm_overwrite_strategy()

        except ValueError as e:
            self.print_error(f"Cannot read existing config: {e}")
            self.print_warning("File appears to be invalid JSON")
            return self._confirm_overwrite_strategy()

    def _prompt_merge_strategy(self, has_hyper_cmd: bool) -> Optional[str]:
        """Prompt user to choose merge strategy when other servers exist."""
        try:
            if has_hyper_cmd:
                self.console.print("\nOptions:")
                self.console.print("  [1] Merge - Update hyper-cmd server, keep other servers")
                self.console.print("  [2] Overwrite - Replace entire file with only hyper-cmd")
                self.console.print("  [3] Cancel")

                while True:
                    response = input("Choose option [1/2/3]: ").strip()
                    if response == "1":
                        return "merge"
                    elif response == "2":
                        return "overwrite"
                    elif response == "3":
                        return None
                    else:
                        self.print_error("Please enter 1, 2, or 3")
            else:
                self.console.print("\nOptions:")
                self.console.print("  [1] Merge - Add hyper-cmd server, keep existing servers")
                self.console.print("  [2] Overwrite - Replace entire file with only hyper-cmd")
                self.console.print("  [3] Cancel")

                while True:
                    response = input("Choose option [1/2/3]: ").strip()
                    if response == "1":
                        return "merge"
                    elif response == "2":
                        return "overwrite"
                    elif response == "3":
                        return None
                    else:
                        self.print_error("Please enter 1, 2, or 3")

        except (EOFError, KeyboardInterrupt):
            return None

    def _confirm_overwrite_strategy(self) -> Optional[str]:
        """Ask user to confirm overwriting existing file."""
        try:
            response = input("Do you want to overwrite the existing .mcp.json file? [y/N]: ")
            return "overwrite" if response.lower().startswith("y") else None
        except (EOFError, KeyboardInterrupt):
            return None

    def _show_config_preview(self, config: dict[str, Any], config_file: Path) -> None:
        """Show a preview of the configuration that will be created."""
        self.print_info(f"Creating MCP configuration at: {config_file}")
        self.console.print("\n[bold]Configuration preview:[/bold]")

        # Show the important parts of the config
        hyper_config = config["mcpServers"]["hyper-cmd"]
        self.console.print("  📋 Server name: [cyan]hyper-cmd[/cyan]")
        self.console.print(f"  🔧 Command: [green]{hyper_config['command']}[/green]")
        self.console.print(f"  📝 Description: {hyper_config['description']}")

        # Show detected tools if any
        detected_tools = self.tool_detector.detect_tools()
        if detected_tools:
            self.console.print("\n[bold]Detected MCP tools:[/bold]")
            for tool in detected_tools:
                self.console.print(f"  🔍 {tool}")

        self.console.print("")

    def _show_merge_preview(
        self, existing_config: dict[str, Any], merged_config: dict[str, Any], config_file: Path
    ) -> None:
        """Show a preview of the merge operation."""
        self.print_info(f"Merging with existing MCP configuration at: {config_file}")

        existing_servers = existing_config.get("mcpServers", {})
        merged_servers = merged_config.get("mcpServers", {})

        self.console.print("\n[bold]Merge preview:[/bold]")

        # Show existing servers that will be kept
        kept_servers = [name for name in existing_servers.keys() if name != "hyper-cmd"]
        if kept_servers:
            self.console.print("  ✓ Keeping existing servers:")
            for server_name in kept_servers:
                self.console.print(f"    • [cyan]{server_name}[/cyan]")

        # Show hyper-cmd server (new or updated)
        if "hyper-cmd" in existing_servers:
            self.console.print("  🔄 Updating server:")
        else:
            self.console.print("  ➕ Adding new server:")

        hyper_config = merged_servers["hyper-cmd"]
        self.console.print(f"    • [green]hyper-cmd[/green] - {hyper_config['description']}")

        total_servers = len(merged_servers)
        self.console.print(f"\n  📊 Total servers after merge: {total_servers}")
        self.console.print("")

    def _write_config_file(self, config_file: Path, config: dict[str, Any]) -> None:
        """Write the configuration file."""
        try:
            self.config_generator.write_config(config_file, config)
        except (OSError, PermissionError) as e:
            raise RuntimeError(f"Failed to write config file: {e}") from e

    def _show_success_message(self, config_file: Path) -> None:
        """Show success message and next steps."""
        self.print_success("✓ MCP configuration created successfully!")
        self._show_next_steps(config_file)

    def _show_next_steps(self, config_file: Path) -> None:
        """Show instructions for what to do after creating the config."""
        self.console.print("\n[bold green]🎉 MCP Configuration Ready![/bold green]")
        self.console.print("\n[bold]Next steps:[/bold]")

        self._show_installation_step()
        self._show_configuration_step(config_file)
        self._show_testing_step()
        self._show_available_commands()
        self._show_tips()

    def _show_installation_step(self) -> None:
        """Show installation step."""
        self.console.print("1. [bold]Install Hyper CLI[/bold] (if not already installed):")
        self.console.print("   [cyan]pip install -e .[/cyan]")

    def _show_configuration_step(self, config_file: Path) -> None:
        """Show configuration step."""
        self.console.print("\n2. [bold]Configure your AI tool[/bold] to use this MCP server:")
        self.console.print(f"   • Point it to: [green]{config_file}[/green]")
        self.console.print("   • Or copy the configuration to your AI tool's MCP config")

    def _show_testing_step(self) -> None:
        """Show testing step."""
        self.console.print("\n3. [bold]Test the connection[/bold]:")
        self.console.print("   • Start your AI tool with MCP support")
        self.console.print("   • Verify it can access Hyper commands")

    def _show_available_commands(self) -> None:
        """Show available commands."""
        self.console.print("\n4. [bold]Available Hyper commands via MCP:[/bold]")

        # List key commands
        key_commands = [
            ("hyper_init", "Initialize Hyper projects"),
            ("hyper_init-mcp", "Generate MCP configuration"),
            ("hyper_hello", "Example plugin command"),
            ("hyper_test", "Run project tests"),
            ("hyper_testinfo", "Test environment info"),
        ]

        for cmd_name, description in key_commands:
            self.console.print(f"   • [cyan]{cmd_name}[/cyan] - {description}")

        self.console.print("   • Plus any additional plugin commands")

    def _show_tips(self) -> None:
        """Show helpful tips."""
        self.console.print("\n[dim]💡 Tip: Use 'hyper --help' to see all available commands[/dim]")
        self.console.print("[dim]📖 Documentation: See MCP_README.md for detailed usage[/dim]")

    def _confirm_proceed(self) -> bool:
        """Ask user to confirm proceeding with MCP initialization."""
        try:
            response = input("Proceed with MCP configuration creation? [Y/n]: ")
            return not response.lower().startswith("n")
        except (EOFError, KeyboardInterrupt):
            return False
